{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"config/","text":"Session Config zend-session comes with a standard set of config classes, allowing setting where a cookie lives, session lifetime, and even configuration of ext/session when using Zend\\Session\\Config\\SessionConfig . Standard Config Zend\\Session\\Config\\StandardConfig provides the base interface for configuring sessions when not leveraging ext/session. This is utilized more for specialized cases, such as when you might have session management done by another system, or when testing. Basic Configuration Options The following configuration options are defined by Zend\\Session\\Config\\StandardConfig . Option Data Type Description cache_expire integer Specifies time-to-live for cached session pages in minutes. cookie_domain string Specifies the domain to set in the session cookie. cookie_httponly boolean Marks the cookie as accessible only through the HTTP protocol. cookie_lifetime integer Specifies the lifetime of the cookie in seconds which is sent to the browser. cookie_path string Specifies path to set in the session cookie. cookie_secure boolean Specifies whether cookies should only be sent over secure connections. entropy_length integer Specifies the number of bytes which will be read from the file specified in entropy_file. Removed in PHP 7.1.0. entropy_file string Defines a path to an external resource (file) which will be used as an additional entropy. Removed in PHP 7.1.0. gc_maxlifetime integer Specifies the number of seconds after which data will be seen as \u2018garbage\u2019. gc_divisor integer Defines the probability that the gc process is started on every session initialization. gc_probability integer Defines the probability that the gc process is started on every session initialization. hash_function integer Defines which built-in hash algorithm is used. Removed in PHP 7.1.0. hash_bits_per_character integer Defines how many bits are stored in each character when converting the binary hash data. Removed in PHP 7.1.0. name string Specifies the name of the session which is used as cookie name. remember_me_seconds integer Specifies how long to remember the session before clearing data. save_path string Defines the argument which is passed to the save handler. use_cookies boolean Specifies whether the module will use cookies to store the session id. Basic Usage use Zend\\Session\\Config\\StandardConfig; use Zend\\Session\\SessionManager; $config = new StandardConfig(); $config->setOptions([ 'remember_me_seconds' => 1800, 'name' => 'zf2', ]); $manager = new SessionManager($config); Session Config Zend\\Session\\Config\\SessionConfig provides an interface for configuring sessions that leverage PHP's ext/session. Most configuration options configure either the Zend\\Session\\Storage OR configure ext/session directly. Basic Configuration Options The following configuration options are defined by Zend\\Session\\Config\\SessionConfig ; note that it inherits all configuration from Zend\\Session\\Config\\StandardConfig . Option Data Type Description cache_limiter string Specifies the cache control method used for session pages. hash_function string Allows you to specify the hash algorithm used to generate the session IDs. php_save_handler string Defines the name of a PHP save_handler embedded into PHP. serialize_handler string Defines the name of the handler which is used to serialize/deserialize data. url_rewriter_tags string Specifies which HTML tags are rewritten to include session id if transparent sid enabled. use_trans_sid boolean Whether transparent sid support is enabled or not. Basic Usage use Zend\\Session\\Config\\SessionConfig; use Zend\\Session\\SessionManager; $config = new SessionConfig(); $config->setOptions([ 'phpSaveHandler' => 'redis', 'savePath' => 'tcp://127.0.0.1:6379?weight=1&timeout=1', ]); $manager = new SessionManager($config); Service Manager Factory zend-session ships with a zend-servicemanager factory which reads configuration data from the application configuration and injects a corresponding instance of Zend\\Session\\Config\\SessionConfig into the session manager automatically. To use this factory, you first need to register it with the service manager by adding the appropriate factory definition: 'service_manager' => [ 'factories' => [ 'Zend\\Session\\Config\\ConfigInterface' => 'Zend\\Session\\Service\\SessionConfigFactory', ], ], Automated factory registration Starting with zend-mvc v3, if you are using the component installer in your application, the above registration will be made automatically for you when you install zend-session. Then place your application's session configuration in the root-level configuration key session_config : 'session_config' => [ 'phpSaveHandler' => 'redis', 'savePath' => 'tcp://127.0.0.1:6379?weight=1&timeout=1', ], Any of the configuration options defined for SessionConfig can be used there, as well as the following factory-specific configuration options: Option Data Type Description config_class string Name of the class to use as the configuration container (Defaults to Zend\\Session\\Config\\SessionConfig ) Custom Configuration In the event that you prefer to create your own session configuration; you must implement Zend\\Session\\Config\\ConfigInterface which contains the basic interface for items needed when implementing a session. This includes cookie configuration, lifetime, session name, save path, and an interface for getting and setting options.","title":"Session Config"},{"location":"config/#session-config","text":"zend-session comes with a standard set of config classes, allowing setting where a cookie lives, session lifetime, and even configuration of ext/session when using Zend\\Session\\Config\\SessionConfig .","title":"Session Config"},{"location":"config/#standard-config","text":"Zend\\Session\\Config\\StandardConfig provides the base interface for configuring sessions when not leveraging ext/session. This is utilized more for specialized cases, such as when you might have session management done by another system, or when testing.","title":"Standard Config"},{"location":"config/#session-config_1","text":"Zend\\Session\\Config\\SessionConfig provides an interface for configuring sessions that leverage PHP's ext/session. Most configuration options configure either the Zend\\Session\\Storage OR configure ext/session directly.","title":"Session Config"},{"location":"config/#custom-configuration","text":"In the event that you prefer to create your own session configuration; you must implement Zend\\Session\\Config\\ConfigInterface which contains the basic interface for items needed when implementing a session. This includes cookie configuration, lifetime, session name, save path, and an interface for getting and setting options.","title":"Custom Configuration"},{"location":"container/","text":"Session Container Zend\\Session\\Container instances provide the primary API for manipulating session data in zend-session. Containers are used to segregate all session data, although a default namespace exists for those who only want one namespace for all their session data. Each instance of Zend\\Session\\Container corresponds to an entry of the Zend\\Session\\Storage , where the namespace is used as the key. Zend\\Session\\Container itself is an instance of an ArrayObject . Basic Usage use Zend\\Session\\Container; $container = new Container('namespace'); $container->item = 'foo'; Setting the Default Session Manager In the event you are using multiple session managers or prefer to be explicit, the default session manager that is utilized can be explicitly set. use Zend\\Session\\Container; use Zend\\Session\\SessionManager; $manager = new SessionManager(); Container::setDefaultManager($manager);","title":"Session Container"},{"location":"container/#session-container","text":"Zend\\Session\\Container instances provide the primary API for manipulating session data in zend-session. Containers are used to segregate all session data, although a default namespace exists for those who only want one namespace for all their session data. Each instance of Zend\\Session\\Container corresponds to an entry of the Zend\\Session\\Storage , where the namespace is used as the key. Zend\\Session\\Container itself is an instance of an ArrayObject .","title":"Session Container"},{"location":"container/#basic-usage","text":"use Zend\\Session\\Container; $container = new Container('namespace'); $container->item = 'foo';","title":"Basic Usage"},{"location":"container/#setting-the-default-session-manager","text":"In the event you are using multiple session managers or prefer to be explicit, the default session manager that is utilized can be explicitly set. use Zend\\Session\\Container; use Zend\\Session\\SessionManager; $manager = new SessionManager(); Container::setDefaultManager($manager);","title":"Setting the Default Session Manager"},{"location":"manager/","text":"Session Manager The session manager, Zend\\Session\\SessionManager , is the class responsible for all aspects of session management. It initializes configuration, storage, and save handlers. Additionally the session manager can be injected into the session container to provide a wrapper or namespace around your session data. The session manager is responsible for starting a session, testing if a session exists, writing to the session, regenerating the session identifier, setting the session time-to-live, and destroying the session. The session manager can validate sessions from a validator chain to ensure that the session data is correct. Initializing the Session Manager Generally speaking, you will always want to initialize the session manager and ensure that your application was responsible for its initialization; this puts in place a simple solution to prevent against session fixation. Generally you will setup configuration and then inside of an application module bootstrap the session manager. Additionally you will likely want to supply validators to prevent against session hijacking. The following illustrates how you may configure the session manager by setting options in your local or global config: use Zend\\Session; return [ 'session_manager' => [ 'config' => [ 'class' => Session\\Config\\SessionConfig::class, 'options' => [ 'name' => 'myapp', ], ], 'storage' => Session\\Storage\\SessionArrayStorage::class, 'validators' => [ Session\\Validator\\RemoteAddr::class, Session\\Validator\\HttpUserAgent::class, ], ], ]; The following illustrates how you might utilize the above configuration to create the session manager: use Zend\\Mvc\\ModuleRouteListener; use Zend\\Mvc\\MvcEvent; use Zend\\Session\\SessionManager; use Zend\\Session\\Config\\SessionConfig; use Zend\\Session\\Container; use Zend\\Session\\Validator; class Module { public function onBootstrap(MvcEvent $e) { $eventManager = $e->getApplication()->getEventManager(); $moduleRouteListener = new ModuleRouteListener(); $moduleRouteListener->attach($eventManager); $this->bootstrapSession($e); } public function bootstrapSession(MvcEvent $e) { $session = $e->getApplication() ->getServiceManager() ->get(SessionManager::class); $session->start(); $container = new Container('initialized'); if (isset($container->init)) { return; } $serviceManager = $e->getApplication()->getServiceManager(); $request = $serviceManager->get('Request'); $session->regenerateId(true); $container->init = 1; $container->remoteAddr = $request->getServer()->get('REMOTE_ADDR'); $container->httpUserAgent = $request->getServer()->get('HTTP_USER_AGENT'); $config = $serviceManager->get('Config'); if (! isset($config['session'])) { return; } $sessionConfig = $config['session']; if (! isset($sessionConfig['validators'])) { return; } $chain = $session->getValidatorChain(); foreach ($sessionConfig['validators'] as $validator) { switch ($validator) { case Validator\\HttpUserAgent::class: $validator = new $validator($container->httpUserAgent); break; case Validator\\RemoteAddr::class: $validator = new $validator($container->remoteAddr); break; default: $validator = new $validator(); break; } $chain->attach('session.validate', array($validator, 'isValid')); } } public function getServiceConfig() { return [ 'factories' => [ SessionManager::class => function ($container) { $config = $container->get('config'); if (! isset($config['session'])) { $sessionManager = new SessionManager(); Container::setDefaultManager($sessionManager); return $sessionManager; } $session = $config['session']; $sessionConfig = null; if (isset($session['config'])) { $class = isset($session['config']['class']) ? $session['config']['class'] : SessionConfig::class; $options = isset($session['config']['options']) ? $session['config']['options'] : []; $sessionConfig = new $class(); $sessionConfig->setOptions($options); } $sessionStorage = null; if (isset($session['storage'])) { $class = $session['storage']; $sessionStorage = new $class(); } $sessionSaveHandler = null; if (isset($session['save_handler'])) { // class should be fetched from service manager // since it will require constructor arguments $sessionSaveHandler = $container->get($session['save_handler']); } $sessionManager = new SessionManager( $sessionConfig, $sessionStorage, $sessionSaveHandler ); Container::setDefaultManager($sessionManager); return $sessionManager; }, ], ]; } } When you create a new Zend\\Session\\Container (see Session Container page) in a controller, for example, it will use the session configured above.","title":"Session Manager"},{"location":"manager/#session-manager","text":"The session manager, Zend\\Session\\SessionManager , is the class responsible for all aspects of session management. It initializes configuration, storage, and save handlers. Additionally the session manager can be injected into the session container to provide a wrapper or namespace around your session data. The session manager is responsible for starting a session, testing if a session exists, writing to the session, regenerating the session identifier, setting the session time-to-live, and destroying the session. The session manager can validate sessions from a validator chain to ensure that the session data is correct.","title":"Session Manager"},{"location":"manager/#initializing-the-session-manager","text":"Generally speaking, you will always want to initialize the session manager and ensure that your application was responsible for its initialization; this puts in place a simple solution to prevent against session fixation. Generally you will setup configuration and then inside of an application module bootstrap the session manager. Additionally you will likely want to supply validators to prevent against session hijacking. The following illustrates how you may configure the session manager by setting options in your local or global config: use Zend\\Session; return [ 'session_manager' => [ 'config' => [ 'class' => Session\\Config\\SessionConfig::class, 'options' => [ 'name' => 'myapp', ], ], 'storage' => Session\\Storage\\SessionArrayStorage::class, 'validators' => [ Session\\Validator\\RemoteAddr::class, Session\\Validator\\HttpUserAgent::class, ], ], ]; The following illustrates how you might utilize the above configuration to create the session manager: use Zend\\Mvc\\ModuleRouteListener; use Zend\\Mvc\\MvcEvent; use Zend\\Session\\SessionManager; use Zend\\Session\\Config\\SessionConfig; use Zend\\Session\\Container; use Zend\\Session\\Validator; class Module { public function onBootstrap(MvcEvent $e) { $eventManager = $e->getApplication()->getEventManager(); $moduleRouteListener = new ModuleRouteListener(); $moduleRouteListener->attach($eventManager); $this->bootstrapSession($e); } public function bootstrapSession(MvcEvent $e) { $session = $e->getApplication() ->getServiceManager() ->get(SessionManager::class); $session->start(); $container = new Container('initialized'); if (isset($container->init)) { return; } $serviceManager = $e->getApplication()->getServiceManager(); $request = $serviceManager->get('Request'); $session->regenerateId(true); $container->init = 1; $container->remoteAddr = $request->getServer()->get('REMOTE_ADDR'); $container->httpUserAgent = $request->getServer()->get('HTTP_USER_AGENT'); $config = $serviceManager->get('Config'); if (! isset($config['session'])) { return; } $sessionConfig = $config['session']; if (! isset($sessionConfig['validators'])) { return; } $chain = $session->getValidatorChain(); foreach ($sessionConfig['validators'] as $validator) { switch ($validator) { case Validator\\HttpUserAgent::class: $validator = new $validator($container->httpUserAgent); break; case Validator\\RemoteAddr::class: $validator = new $validator($container->remoteAddr); break; default: $validator = new $validator(); break; } $chain->attach('session.validate', array($validator, 'isValid')); } } public function getServiceConfig() { return [ 'factories' => [ SessionManager::class => function ($container) { $config = $container->get('config'); if (! isset($config['session'])) { $sessionManager = new SessionManager(); Container::setDefaultManager($sessionManager); return $sessionManager; } $session = $config['session']; $sessionConfig = null; if (isset($session['config'])) { $class = isset($session['config']['class']) ? $session['config']['class'] : SessionConfig::class; $options = isset($session['config']['options']) ? $session['config']['options'] : []; $sessionConfig = new $class(); $sessionConfig->setOptions($options); } $sessionStorage = null; if (isset($session['storage'])) { $class = $session['storage']; $sessionStorage = new $class(); } $sessionSaveHandler = null; if (isset($session['save_handler'])) { // class should be fetched from service manager // since it will require constructor arguments $sessionSaveHandler = $container->get($session['save_handler']); } $sessionManager = new SessionManager( $sessionConfig, $sessionStorage, $sessionSaveHandler ); Container::setDefaultManager($sessionManager); return $sessionManager; }, ], ]; } } When you create a new Zend\\Session\\Container (see Session Container page) in a controller, for example, it will use the session configured above.","title":"Initializing the Session Manager"},{"location":"save-handler/","text":"Session Save Handlers zend-session comes with a set of save handler classes. Save handlers themselves are decoupled from PHP's save handler functions and are only implemented as a PHP save handler when utilized in conjunction with Zend\\Session\\SessionManager . Cache Zend\\Session\\SaveHandler\\Cache allows you to provide an instance of Zend\\Cache\\Storage\\Adapter\\AdapterInterface to be utilized as a session save handler. Generally if you are utilizing the Cache save handler; you are likely using products such as memcached. Basic usage A basic example is one like the following: use Zend\\Cache\\StorageFactory; use Zend\\Session\\SaveHandler\\Cache; use Zend\\Session\\SessionManager; $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'memcached', 'options' => [ 'server' => '127.0.0.1', ], ], ]); $saveHandler = new Cache($cache); $manager = new SessionManager(); $manager->setSaveHandler($saveHandler); DbTableGateway Zend\\Session\\SaveHandler\\DbTableGateway allows you to utilize Zend\\Db\\TableGateway\\TableGatewayInterface implementations as a session save handler. Setup of a DbTableGateway save handler requires an instance of Zend\\Db\\TableGateway\\TableGatewayInterface and an instance of Zend\\Session\\SaveHandler\\DbTableGatewayOptions . In the most basic setup, a TableGateway object and using the defaults of the DbTableGatewayOptions will provide you with what you need. Creating the database table CREATE TABLE `session` ( `id` char(32), `name` char(32), `modified` int, `lifetime` int, `data` text, PRIMARY KEY (`id`, `name`) ); Basic usage use Zend\\Db\\TableGateway\\TableGateway; use Zend\\Session\\SaveHandler\\DbTableGateway; use Zend\\Session\\SaveHandler\\DbTableGatewayOptions; use Zend\\Session\\SessionManager; $tableGateway = new TableGateway('session', $adapter); $saveHandler = new DbTableGateway($tableGateway, new DbTableGatewayOptions()); $manager = new SessionManager(); $manager->setSaveHandler($saveHandler); MongoDB Zend\\Session\\SaveHandler\\MongoDB allows you to provide a MongoDB collection to be utilized as a session save handler. You provide the options in the Zend\\Session\\SaveHandler\\MongoDBOptions class. You must install the mongodb PHP extensions and the MongoDB PHP library . Basic Usage use MongoDB\\Client; use Zend\\Session\\SaveHandler\\MongoDB; use Zend\\Session\\SaveHandler\\MongoDBOptions; use Zend\\Session\\SessionManager; $mongoClient = new Client(); $options = new MongoDBOptions([ 'database' => 'myapp', 'collection' => 'sessions', ]); $saveHandler = new MongoDB($mongoClient, $options); $manager = new SessionManager(); $manager->setSaveHandler($saveHandler); Custom Save Handlers There may be cases where you want to create a save handler. Creating a custom save handler is much like creating a custom PHP save handler, with minor differences. All zend-session-compatible save handlers must implement Zend\\Session\\SaveHandler\\SaveHandlerInterface . Additionally, if your save handler has configurable functionality, you will also need to create an options class.","title":"Session Save Handlers"},{"location":"save-handler/#session-save-handlers","text":"zend-session comes with a set of save handler classes. Save handlers themselves are decoupled from PHP's save handler functions and are only implemented as a PHP save handler when utilized in conjunction with Zend\\Session\\SessionManager .","title":"Session Save Handlers"},{"location":"save-handler/#cache","text":"Zend\\Session\\SaveHandler\\Cache allows you to provide an instance of Zend\\Cache\\Storage\\Adapter\\AdapterInterface to be utilized as a session save handler. Generally if you are utilizing the Cache save handler; you are likely using products such as memcached.","title":"Cache"},{"location":"save-handler/#dbtablegateway","text":"Zend\\Session\\SaveHandler\\DbTableGateway allows you to utilize Zend\\Db\\TableGateway\\TableGatewayInterface implementations as a session save handler. Setup of a DbTableGateway save handler requires an instance of Zend\\Db\\TableGateway\\TableGatewayInterface and an instance of Zend\\Session\\SaveHandler\\DbTableGatewayOptions . In the most basic setup, a TableGateway object and using the defaults of the DbTableGatewayOptions will provide you with what you need.","title":"DbTableGateway"},{"location":"save-handler/#mongodb","text":"Zend\\Session\\SaveHandler\\MongoDB allows you to provide a MongoDB collection to be utilized as a session save handler. You provide the options in the Zend\\Session\\SaveHandler\\MongoDBOptions class. You must install the mongodb PHP extensions and the MongoDB PHP library .","title":"MongoDB"},{"location":"save-handler/#custom-save-handlers","text":"There may be cases where you want to create a save handler. Creating a custom save handler is much like creating a custom PHP save handler, with minor differences. All zend-session-compatible save handlers must implement Zend\\Session\\SaveHandler\\SaveHandlerInterface . Additionally, if your save handler has configurable functionality, you will also need to create an options class.","title":"Custom Save Handlers"},{"location":"storage/","text":"Session Storage zend-session comes with a standard set of storage handlers. Storage handlers are the intermediary between when the session starts and when the session writes and closes. The default session storage is Zend\\Session\\Storage\\SessionArrayStorage . Array Storage Zend\\Session\\Storage\\ArrayStorage provides a facility to store all information in an ArrayObject . This storage method is likely incompatible with 3rd party libraries and all properties will be inaccessible through the $_SESSION superglobal. Additionally ArrayStorage will not automatically repopulate the storage container in the case of each new request and would have to manually be re-populated. Basic Usage use Zend\\Session\\Storage\\ArrayStorage; use Zend\\Session\\SessionManager; $populateStorage = ['foo' => 'bar']; $storage = new ArrayStorage($populateStorage); $manager = new SessionManager(); $manager->setStorage($storage); Session Storage Zend\\Session\\Storage\\SessionStorage replaces $_SESSION, providing a facility to store all information in an ArrayObject . This means that it may not be compatible with 3rd party libraries, although information stored in the $_SESSION superglobal should be available in other scopes. Basic Usage use Zend\\Session\\Storage\\SessionStorage; use Zend\\Session\\SessionManager; $manager = new SessionManager(); $manager->setStorage(new SessionStorage()); Session Array Storage Zend\\Session\\Storage\\SessionArrayStorage provides a facility to store all information directly in the $_SESSION superglobal. This storage class provides the most compatibility with 3rd party libraries and allows for directly storing information into $_SESSION . Basic Usage use Zend\\Session\\Storage\\SessionArrayStorage; use Zend\\Session\\SessionManager; $manager = new SessionManager(); $manager->setStorage(new SessionArrayStorage()); Custom Storage To create a custom storage container, you must implement Zend\\Session\\Storage\\StorageInterface . This interface extends each of ArrayAccess , Traversable , Serializable , and Countable , and it is in the methods those define that the majority of implementation occurs. The following methods must also be implemented: public function getRequestAccessTime() : int; public function lock(int|string $key = null) : void; public function isLocked(int|string $key = null) : bool; public function unlock(int|string $key = null) : void; public function markImmutable() : void; public function isImmutable() : bool; public function setMetadata(string $key, mixed $value, bool $overwriteArray = false) : void; public function getMetadata(string $key = null) : mixed; public function clear(inst|string $key = null) : void; public function fromArray(array $array) : void; public function toArray(bool $metaData = false) : array;","title":"Session Storage"},{"location":"storage/#session-storage","text":"zend-session comes with a standard set of storage handlers. Storage handlers are the intermediary between when the session starts and when the session writes and closes. The default session storage is Zend\\Session\\Storage\\SessionArrayStorage .","title":"Session Storage"},{"location":"storage/#array-storage","text":"Zend\\Session\\Storage\\ArrayStorage provides a facility to store all information in an ArrayObject . This storage method is likely incompatible with 3rd party libraries and all properties will be inaccessible through the $_SESSION superglobal. Additionally ArrayStorage will not automatically repopulate the storage container in the case of each new request and would have to manually be re-populated.","title":"Array Storage"},{"location":"storage/#session-storage_1","text":"Zend\\Session\\Storage\\SessionStorage replaces $_SESSION, providing a facility to store all information in an ArrayObject . This means that it may not be compatible with 3rd party libraries, although information stored in the $_SESSION superglobal should be available in other scopes.","title":"Session Storage"},{"location":"storage/#session-array-storage","text":"Zend\\Session\\Storage\\SessionArrayStorage provides a facility to store all information directly in the $_SESSION superglobal. This storage class provides the most compatibility with 3rd party libraries and allows for directly storing information into $_SESSION .","title":"Session Array Storage"},{"location":"storage/#custom-storage","text":"To create a custom storage container, you must implement Zend\\Session\\Storage\\StorageInterface . This interface extends each of ArrayAccess , Traversable , Serializable , and Countable , and it is in the methods those define that the majority of implementation occurs. The following methods must also be implemented: public function getRequestAccessTime() : int; public function lock(int|string $key = null) : void; public function isLocked(int|string $key = null) : bool; public function unlock(int|string $key = null) : void; public function markImmutable() : void; public function isImmutable() : bool; public function setMetadata(string $key, mixed $value, bool $overwriteArray = false) : void; public function getMetadata(string $key = null) : mixed; public function clear(inst|string $key = null) : void; public function fromArray(array $array) : void; public function toArray(bool $metaData = false) : array;","title":"Custom Storage"},{"location":"validator/","text":"Session Validators Session validators provide protections against session hijacking. Http User Agent Zend\\Session\\Validator\\HttpUserAgent provides a validator to check the session against the originally stored $_SERVER['HTTP_USER_AGENT'] variable. Validation will fail in the event that this does not match and throws an exception in Zend\\Session\\SessionManager after session_start() has been called. Basic Usage use Zend\\Session\\Validator\\HttpUserAgent; use Zend\\Session\\SessionManager; $manager = new SessionManager(); $manager->getValidatorChain() ->attach('session.validate', [new HttpUserAgent(), 'isValid']); Remote Addr Zend\\Session\\Validator\\RemoteAddr provides a validator to check the session against the originally stored $_SERVER['REMOTE_ADDR'] variable. Validation will fail in the event that this does not match and throws an exception in Zend\\Session\\SessionManager after session_start() has been called. Basic Usage use Zend\\Session\\Validator\\RemoteAddr; use Zend\\Session\\SessionManager; $manager = new SessionManager(); $manager->getValidatorChain() ->attach('session.validate', [new RemoteAddr(), 'isValid']); Custom Validators You may want to provide your own custom validators to validate against other items from storing a token and validating a token to other various techniques. To create a custom validator you must implement the validation interface Zend\\Session\\Validator\\ValidatorInterface .","title":"Session Validators"},{"location":"validator/#session-validators","text":"Session validators provide protections against session hijacking.","title":"Session Validators"},{"location":"validator/#http-user-agent","text":"Zend\\Session\\Validator\\HttpUserAgent provides a validator to check the session against the originally stored $_SERVER['HTTP_USER_AGENT'] variable. Validation will fail in the event that this does not match and throws an exception in Zend\\Session\\SessionManager after session_start() has been called.","title":"Http User Agent"},{"location":"validator/#remote-addr","text":"Zend\\Session\\Validator\\RemoteAddr provides a validator to check the session against the originally stored $_SERVER['REMOTE_ADDR'] variable. Validation will fail in the event that this does not match and throws an exception in Zend\\Session\\SessionManager after session_start() has been called.","title":"Remote Addr"},{"location":"validator/#custom-validators","text":"You may want to provide your own custom validators to validate against other items from storing a token and validating a token to other various techniques. To create a custom validator you must implement the validation interface Zend\\Session\\Validator\\ValidatorInterface .","title":"Custom Validators"}]}